Problem 7:(The execution method: python3 ml2_p7.py)
I calculate the Ein, Eout, (Ein - Eout) for 1000 times. Every time, generate 20 x by random.uniform(-1, 1). Then generate y by generating the probability between 0 and 1, if the probility < 0.2, then it will be seen as a noise and the y will be -sign(x); otherwise, it will be sign(x). Then generate theta by sorting the 20 x first and find the midimum of x and (x + 1) to be theta. Since there are 40 sets of (s, theta), there will be 40 error rate, and find the smallest to be Ein. Moreover, use the set of (s, theta) which generates the Ein to be the parameters for Eout, and use the formula calculated in Problem 6 to find the Eout.

Problem 8:(The execution method: python3 mlhw2_p8.py, it runs approximately 1 minute)
The procedure is similar to that in Problem 7. But in order to avoid running for so long, I use numpy to store X and Y. So this time, I need to store the result of Y != (s * np.sign(X - theta)) in another numpy and to calculate the number of nonzeros (since if it is an error (not equal), the information in the numpy array will be true, then the total error number can be calculated by number of nonzeros). Then Ein and Eout can be found by the same method as Problem 7.
